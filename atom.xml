<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>tSupan</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-02-27T13:05:16.368Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>tSupan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>微分中值定理与导数的应用</title>
    <link href="http://yoursite.com/2020/02/27/%E5%BE%AE%E5%88%86%E4%B8%AD%E5%80%BC%E5%AE%9A%E7%90%86%E4%B8%8E%E5%AF%BC%E6%95%B0%E7%9A%84%E5%BA%94%E7%94%A8/"/>
    <id>http://yoursite.com/2020/02/27/微分中值定理与导数的应用/</id>
    <published>2020-02-27T13:05:16.367Z</published>
    <updated>2020-02-27T13:05:16.368Z</updated>
    
    <content type="html"><![CDATA[<h1 id="微分中值定理使用要求在这里">微分中值定理（使用要求在这里）</h1><p>使用要求：</p><p>(1)在闭区间[a, b]上连续</p><p>(2)在开区间(a, b)内可导</p><h2 id="罗尔定理拉格朗日中值定理">罗尔定理、拉格朗日中值定理</h2><p>罗尔定理为拉格朗日中值定理的特殊情形</p><h3 id="拉格朗日中值定理">拉格朗日中值定理</h3><p>在使用要求的前提下，有函数f(x)</p><p>可得<span class="math inline">\((a, b)\)</span>内至少有一点<span class="math inline">\(\xi(a&lt;\xi&lt;b)\)</span>，使<span class="math inline">\(f(b)-f(a)=f&#39;(\xi)(b-a)\)</span></p><h3 id="罗尔定理">罗尔定理</h3><p>在上面拉格朗日中值定理要求基础上添加一条<span class="math inline">\(f(a)=f(b)\)</span>的要求</p><p>则<span class="math inline">\((a, b)\)</span>内至少有一点<span class="math inline">\(\xi(a&lt;\xi&lt;b)\)</span>，使<span class="math inline">\(f&#39;(\xi)=0\)</span></p><h2 id="柯西中值定理">柯西中值定理</h2><p>在使用要求的前提下，分别有两个函数<span class="math inline">\(f(x)\)</span>和<span class="math inline">\(F(x)\)</span></p><p>添加一个要求：任一<span class="math inline">\(x\in(a, b)\)</span>，使<span class="math inline">\(F&#39;(x)\not=0\)</span></p><p>则<span class="math inline">\((a, b)\)</span>内至少有一点<span class="math inline">\(\xi(a&lt;\xi&lt;b)\)</span>，使<span class="math inline">\(\frac{f(b)-f(a)}{F(b)-F(a)}=\frac{f&#39;(\xi)}{F&#39;(\xi)}\)</span></p><h1 id="洛必达法则">洛必达法则</h1><h2 id="定理一">定理一</h2><p>(1)当<span class="math inline">\(x\rightarrow a\)</span>时，函数<span class="math inline">\(f(x)\approx 0 \text{&amp;} F(x)\approx 0\)</span>(趋近于0)</p><p>(2)在点a的某去心领域内，f'(x)及F'(x)都存在且<span class="math inline">\(F&#39;(x)\not= 0\)</span></p><p>(3)<span class="math inline">\(\displaystyle\lim_{x\rightarrow a}\frac{f&#39;(x)}{F&#39;(x)}\)</span>存在(或为无穷大)</p><p>则<span class="math inline">\(\displaystyle\lim_{x\rightarrow a}\frac{f(x)}{F(x)} = \lim_{x\rightarrow a}\frac{f&#39;(x)}{F&#39;(x)}\)</span></p><h2 id="定理二">定理二</h2><p>(1)当<span class="math inline">\(x\rightarrow \infty\)</span>时，函数<span class="math inline">\(f(x)\approx 0 \text{&amp;} F(x)\approx 0\)</span>(趋近于0)</p><p>(2)当<span class="math inline">\(|x|&gt;N\)</span>时<span class="math inline">\(f&#39;(x)\)</span>与<span class="math inline">\(F&#39;(x)\)</span>都存在，且<span class="math inline">\(F&#39;(x)\not= 0\)</span></p><p>(3)<span class="math inline">\(\displaystyle\lim_{x\rightarrow \infty}\frac{f&#39;(x)}{F&#39;(x)}\)</span>存在(或为无穷大)</p><p>则<span class="math inline">\(\displaystyle\lim_{x\rightarrow \infty}\frac{f(x)}{F(x)} = \lim_{x\rightarrow a}\frac{f&#39;(x)}{F&#39;(x)}\)</span></p><h1 id="泰勒公式">泰勒公式</h1><h2 id="公式原型">公式原型</h2><p><span class="math display">\[f(x)=f(x_0)+\frac{f^{(1)}(x_0)}{1!}(x-x_0)+\frac{f^{(2)}(x_0)}{2!}(x-x_0)^{2}+...+\frac{f^{(n)}(x_0)}{n!}(x-x_0)^{n}+R_n(x)\]</span></p><p>当存在n阶导数时，<span class="math inline">\(R_n(x)\)</span>为佩亚诺余项。当存在(n+1)阶导数时，<span class="math inline">\(R_n(x)\)</span>为拉格朗日余项</p><h2 id="各个余项式子">各个余项式子</h2><h3 id="佩亚诺余项">佩亚诺余项</h3><p><span class="math display">\[R_n(x)=o((x-x_0)^n)\]</span></p><h3 id="拉格朗日余项">拉格朗日余项</h3><p><span class="math display">\[R_n(x)=\frac{f^{(n+1)}(\xi)}{(n+1)!}(x-x_0)^{n+1}\]</span> 其中<span class="math inline">\(\xi\)</span>的值在<span class="math inline">\(x_0\)</span>和x之间</p><h2 id="r_nx估计式"><span class="math inline">\(R_n(x)\)</span>估计式</h2><p><span class="math display">\[|R_n(x)|=\begin{vmatrix}\frac{f^{(n+1)}(\xi)}{(n+1)!}(x-x_0)^{n+1}\end{vmatrix}\leq \frac{M}{(n+1)!}|x-x_0|^{(n+1)}\]</span> 当<span class="math inline">\(\xi=0\)</span>时=号成立</p><h2 id="麦克劳林公式">麦克劳林公式</h2><p>在泰勒公式中取<span class="math inline">\(x_0=0\)</span>即为麦克劳林公式，也即 <span class="math display">\[f(x)=f(0)+\frac{f^{(1)}(0)}{1!}x+\frac{f^{(2)}(0)}{2!}x^{2}+...+\frac{f^{(n)}(0)}{n!}x^{n}+R_n(x)\]</span></p><h2 id="泰勒公式在初等函数均使用麦克劳林公式所求">泰勒公式在初等函数（均使用麦克劳林公式所求）</h2><p><span class="math display">\[e^x=1+x+\frac{x^2}{2!}+...+\frac{x^n}{n!}+R_n(x)\]</span> <span class="math display">\[\sin x = x-\frac{x^3}{3!}+\frac{x^5}{5!}-...+(-1)^{m-1}\frac{x^{2m-1}}{(2m-1)!}+R_{2m}(x)\]</span> <span class="math display">\[\cos x=1-\frac{1}{2!}x^2+\frac{1}{4!}x^4-...+(-1)^m\frac{1}{(2m)!}x^{2m}+R_{2m+1}(x)\]</span> <span class="math display">\[\ln(1+x)=x-\frac{1}{2}x^2+\frac{1}{3}x^3-...+(-1)^{n-1}\frac{1}{n}x^n+R_n(x)\]</span> <span class="math display">\[(1+x)^\alpha=1+\alpha x+\frac{\alpha(\alpha-1)}{2!}x^2+...+\frac{\alpha(\alpha-1)...(\alpha-n+1)}{n!}x^n+R_n(x)\]</span></p><h1 id="曲线的凹凸性与拐点">曲线的凹凸性与拐点</h1><h2 id="凹凸性">凹凸性</h2><p>一个函数，有任意两点a, b</p><p>如果<span class="math inline">\(f(\frac{a+b}{2})&gt;\frac{f(a)+f(b)}{2}\)</span>，为凹弧(<span class="math inline">\(f&#39;&#39;(x) &gt; 0\)</span>)；反之，则为凸弧(<span class="math inline">\(f&#39;&#39;(x) &lt; 0\)</span>)</p><h2 id="拐点">拐点</h2><p>f'(x)的单调增减区间发生变化的分界点就是拐点(也即求<span class="math inline">\(f&#39;&#39;(x)=0\)</span>，并且<span class="math inline">\(f&#39;&#39;(x)\)</span>两侧异号)</p><h1 id="函数极大值极小值">函数极大值极小值</h1><h2 id="极大小值">极大（小）值</h2><p>即<span class="math inline">\(f&#39;(x)=0\)</span>但<span class="math inline">\(f&#39;(x)\)</span>两侧均&gt;0(或&lt;0)为极小值(极大值)点</p><p>但极小值(极大值)不一定为最小值(最大值)。需再求两侧端点的值，或证明该点是该区间的唯一解(也就是f'(x)=0的唯一解)，才能得出是最大值或最小值</p><h2 id="简易求极大值极小值">简易求极大值极小值</h2><p><span class="math inline">\(f&#39;(x)=0\)</span>且<span class="math inline">\(f&#39;&#39;(x)&gt;0\)</span>，为极小值(凹弧)</p><p><span class="math inline">\(f&#39;(x)=0\)</span>且<span class="math inline">\(f&#39;&#39;(x)&lt;0\)</span>，为极大值(凸弧)</p><p>注意：在<span class="math inline">\(f&#39;&#39;(x)=0\)</span>时无法使用</p><h1 id="曲率重要">曲率（重要）</h1><p>应用：研究曲线的弯曲程度</p><h2 id="弧微分公式">弧微分公式</h2><p><span class="math display">\[ds=\sqrt{1+y&#39;^2}dx\]</span></p><p>其中ds为弧线的增量，也就是类似于平常函数中的<span class="math inline">\(\Delta y\)</span></p><h2 id="曲率公式">曲率公式</h2><h3 id="形式1">形式1</h3><p><span class="math display">\[K=\frac{|y&#39;&#39;|}{(1+y&#39;^2)^{3/2}}\]</span></p><h3 id="形式2">形式2</h3><p><span class="math display">\[\begin{cases}x=\varphi (t)\\y=\psi (t)\end{cases}\]</span> <span class="math display">\[K=\frac{|\varphi &#39;(t)\psi &#39;&#39;(t)-\varphi &#39;&#39;(t)\psi &#39;(t)|}{[\varphi &#39;^2(t)+\psi &#39;^2(t)]^{\frac{3}{2}}}\]</span></p><h2 id="曲率圆">曲率圆</h2><h3 id="曲率圆半径">曲率圆半径</h3><p><span class="math display">\[\rho=\frac{1}{K}\]</span></p><h3 id="曲率中心点dalphabeta">曲率中心点<span class="math inline">\(D(\alpha,\beta)\)</span></h3><p><span class="math display">\[\begin{cases}\alpha = x-\frac{y&#39;(1+y&#39;^2)}{y&#39;&#39;}\\\beta = y+\frac{1+y&#39;^2}{y&#39;&#39;}\end{cases}\]</span></p><h3 id="曲率圆方程">曲率圆方程</h3><p><span class="math display">\[(x-\alpha)^2+(y-\beta)^2=\rho^2\]</span></p><h3 id="渐屈线方程未完善">渐屈线方程（未完善）</h3><p>曲率中心点的<span class="math inline">\(\alpha\)</span>和<span class="math inline">\(\beta\)</span>即为相关参数方程</p><h1 id="方程近似解">方程近似解</h1><h2 id="二分法">二分法</h2><p>类似于计算机的二分查找，不断查询中间值，直到找到近似解</p><h2 id="切线法牛顿迭代法">切线法（牛顿迭代法）</h2><p>求出斜率k，也就是函数f(x)的导数，然后通过直线方程<span class="math inline">\((y-y_0)=f&#39;(x_0)(x-x_0)\)</span>求近似值，其中<span class="math inline">\(y=0\)</span></p><p>也即<span class="math inline">\(x_1=x_0-\frac{f(x_0)}{f&#39;(x_0)}\)</span></p><p>不断迭代求<span class="math inline">\(x_n\)</span></p><h2 id="割线法">割线法</h2><p>切线法的改进版</p><p>直接算两点的直线方程，然后通过直线方程<span class="math inline">\((y-y_0)=\frac{x_1-x_0}{f(x_1)-f(x_0)}(x-x_0)\)</span>求近似值</p><p>也就是将<span class="math inline">\(f&#39;(x_0)\)</span>替换成<span class="math inline">\(\frac{x_1-x_0}{f(x_1)-f(x_0)}\)</span></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;微分中值定理使用要求在这里&quot;&gt;微分中值定理（使用要求在这里）&lt;/h1&gt;
&lt;p&gt;使用要求：&lt;/p&gt;
&lt;p&gt;(1)在闭区间[a, b]上连续&lt;/p&gt;
&lt;p&gt;(2)在开区间(a, b)内可导&lt;/p&gt;
&lt;h2 id=&quot;罗尔定理拉格朗日中值定理&quot;&gt;罗尔定理、拉格朗日
      
    
    </summary>
    
      <category term="高等数学" scheme="http://yoursite.com/categories/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/"/>
    
    
      <category term="未完整博客" scheme="http://yoursite.com/tags/%E6%9C%AA%E5%AE%8C%E6%95%B4%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="微分中值定理与导数的应用" scheme="http://yoursite.com/tags/%E5%BE%AE%E5%88%86%E4%B8%AD%E5%80%BC%E5%AE%9A%E7%90%86%E4%B8%8E%E5%AF%BC%E6%95%B0%E7%9A%84%E5%BA%94%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>导数与微分</title>
    <link href="http://yoursite.com/2020/02/05/%E5%AF%BC%E6%95%B0%E4%B8%8E%E5%BE%AE%E5%88%86/"/>
    <id>http://yoursite.com/2020/02/05/导数与微分/</id>
    <published>2020-02-05T14:26:39.826Z</published>
    <updated>2020-02-05T14:26:39.826Z</updated>
    
    <content type="html"><![CDATA[<h1 id="高中三角函数公式重要">高中三角函数公式（重要）</h1><h2 id="反三角函数理清关系">反三角函数（理清关系）</h2><p><span class="math display">\[y=\arcsin x\ \ \text{也即}\sin y=x\]</span></p><h3 id="相关公式">相关公式</h3><p><span class="math display">\[\arcsin(-x)=-\arcsin x\]</span> <span class="math display">\[\arccos(-x)=\pi -\arccos x\]</span> <span class="math display">\[\arctan(-x)=-\arctan x\]</span> <span class="math display">\[\arcsin x+\arccos x=\frac{\pi}{2}=\arctan x+\text{arccot} x\]</span></p><h2 id="三角函数">三角函数</h2><p>在直角三角形中<span class="math inline">\(\Theta\)</span>为b和c的夹角，如下图 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  &#x2F;|</span><br><span class="line">c&#x2F; |a</span><br><span class="line">&#x2F;__|</span><br><span class="line">  b</span><br></pre></td></tr></table></figure></p><p><span class="math display">\[\tan x=\frac{\sin x}{\cos x}=\frac{\sec x}{\csc x}\]</span></p><h3 id="余割">余割</h3><p><span class="math display">\[\csc x=\frac{1}{\sin x}\]</span> <span class="math display">\[\csc \Theta=\frac{c}{a}\]</span></p><h3 id="正割">正割</h3><p><span class="math display">\[\sec x=\frac{1}{\cos x}\]</span> <span class="math display">\[\sec \Theta=\frac{c}{b}\]</span></p><h3 id="余切">余切</h3><p><span class="math display">\[\cot x=\frac{\cos x}{\sin x}\]</span> <span class="math display">\[\cot \Theta=\frac{b}{a}\]</span></p><h1 id="求导">求导</h1><h2 id="求导公式重要">求导公式（重要）</h2><h3 id="常数">常数</h3><p><span class="math display">\[(C)&#39;=0\]</span></p><h3 id="幂函数">幂函数</h3><p><span class="math display">\[(x^{u})&#39;=\mu x^{\mu-1}\]</span></p><h3 id="三角函数-1">三角函数</h3><p><span class="math display">\[正弦：(\sin x)&#39;=\cos x\]</span> <span class="math display">\[余弦：(\cos x)&#39;=-\sin x\]</span> <span class="math display">\[正切：(\tan x)&#39;=\sec ^2 x\]</span> <span class="math display">\[余割：(\csc x)&#39;=-\csc x\cot x\]</span> <span class="math display">\[正割：(\sec x)&#39;=\sec x\tan x\]</span> <span class="math display">\[余切：(\cot x)&#39;=-\csc ^2 x\]</span> <span class="math display">\[反正弦：(\arcsin x)&#39;=\frac{1}{\sqrt{1-x^2}}\]</span> <span class="math display">\[反余弦：(\arccos x)&#39;=-\frac{1}{\sqrt{1-x^2}}\]</span> <span class="math display">\[反正切：(\arctan x)&#39;=\frac{1}{1+x^2}\]</span> <span class="math display">\[反余切：(\text{arccot}\ x)&#39;=-\frac{1}{1+x^2}\]</span></p><h3 id="指数函数">指数函数</h3><p><span class="math display">\[(a^{x})&#39;=a^{x}\ln a(a&gt;0,a\not=1)\]</span> <span class="math display">\[\text{特殊：}(e^{x})&#39;=e^x\]</span></p><h3 id="对数函数">对数函数</h3><p><span class="math display">\[(\log_{a}{x})&#39;=\frac{1}{x\ln a}(a&gt;0,a\not=1)\]</span> <span class="math display">\[\text{特殊：a=e时}\ (\ln x)&#39;=\frac{1}{x}\]</span></p><h3 id="双曲函数">双曲函数</h3><p><span class="math display">\[(sh x)&#39;=ch x\]</span> <span class="math display">\[(ch x)&#39;=sh x\]</span> <span class="math display">\[(th x)&#39;=\frac{1}{ch^2x}\]</span> <span class="math display">\[(arsh x)&#39;=\frac{1}{\sqrt{1+x^2}}\]</span> <span class="math display">\[(arch x)&#39;=\frac{1}{\sqrt{x^2-1}}\]</span> <span class="math display">\[(arth x)&#39;=\frac{1}{\sqrt{1-x^2}}\]</span></p><h2 id="导数的切线方程以及法线方程">导数的切线方程以及法线方程</h2><p>其中<span class="math inline">\((x_0, y_0)\)</span>为坐标点</p><p>切线方程 <span class="math inline">\(y-y_{0}=f&#39;(x_{0})(x-x_{0})\)</span></p><p>法线方程 <span class="math inline">\(y-y_{0}=-\frac{1}{f&#39;(x_{0})}(x-x_{0})\)</span></p><h2 id="求导法则重要">求导法则（重要）</h2><h3 id="和差">和&amp;差</h3><p><span class="math display">\[[u(x)\pm v(x)]&#39;=u&#39;(x)\pm v&#39;(x)\]</span></p><h3 id="积">积</h3><p><span class="math display">\[[u(x)*v(x)]&#39;=u&#39;(x)*v(x)+u(x)*v&#39;(x)\]</span></p><h3 id="商">商</h3><p><span class="math display">\[\left(\frac{u(x)}{v(x)}\right)&#39;=\frac{u&#39;(x)*v(x)+u(x)*v&#39;(x)}{v^2(x)}\]</span></p><h1 id="高阶导数">高阶导数</h1><p>n阶导数一般这样子记 <span class="math display">\[\frac{d^{n}y}{dx^{n}}\]</span></p><h2 id="高阶导数公式重要">高阶导数公式（重要）</h2><h3 id="指数函数-1">指数函数</h3><p><span class="math display">\[(e^x)^{(n)}=e^x\]</span></p><h3 id="正弦余弦">正弦余弦</h3><p><span class="math display">\[(\sin x)^{(n)}=\sin (x+n*\frac{\Pi}{2})\]</span></p><p><span class="math display">\[(\cos x)^{(n)}=\cos (x+n*\frac{\Pi}{2})\]</span></p><h3 id="对数函数-1">对数函数</h3><p><span class="math display">\[[\ln (1+x)]^{(n)}=(-1)^{n-1}\frac{(n-1)!}{(1+x)^n}\]</span></p><h3 id="幂函数-1">幂函数</h3><p><span class="math display">\[(x^\mu)^{(n)}=\begin{cases}\mu(\mu-1)(\mu-2)...(\mu -n+1)x^{\mu -n}   &amp; n&lt;\mu \\n!  &amp; n=\mu \\0  &amp; n&gt;\mu\end{cases}\]</span></p><h3 id="莱布尼兹公式类杨辉三角uvn">莱布尼兹公式（类杨辉三角）<span class="math inline">\((uv)^{(n)}\)</span></h3><p><span class="math display">\[(uv)^{(n)}=\sum_{k=0}^{n}C_n^k u^{(n-k)} v^{(k)}\]</span></p><h1 id="隐函数求导注意事项">隐函数求导注意事项</h1><h2 id="隐函数一阶导数">隐函数一阶导数</h2><p><span class="math display">\[\frac{\frac{dy}{dt}}{\frac{dx}{dt}}\text{相当于上面对y求导，然后下面是对x求导}\]</span></p><h2 id="隐函数二阶导数">隐函数二阶导数</h2><p><span class="math display">\[\frac{d^2y}{dx^2}=\frac{d\frac{\frac{\frac{dy}{dt}}{\frac{dx}{dt}}}{dt}}{\frac{dx}{dt}}=\frac{d\frac{\frac{dy}{dt}}{\frac{dx}{dt}}}{dt}*\frac{dt}{dx}\]</span></p><p>以此类推隐函数n阶导数</p><h1 id="微分">微分</h1><p>微分(dy)就是在原函数上求导得到<span class="math inline">\(\frac{dy}{dx}\)</span>，然后将dx挪至等式右边</p><p>微分作用就是可以求函数在变化很小的情况下（例如<span class="math inline">\(\Delta x=0.000000001\)</span>）函数的近似值</p><p>例如：</p><p><span class="math display">\[dy=(\sin x)&#39;dx\]</span></p><h1 id="其他杂七杂八公式">其他杂七杂八公式</h1><h2 id="扇形公式">扇形公式</h2><p>面积公式：</p><p><span class="math display">\[S=\frac{LR}{2}=\frac{n\Pi R^2}{360}\text{（其中n为角度，非弧度）}\]</span></p><p>弧长公式：</p><p><span class="math display">\[L=R\alpha\]</span></p><h2 id="对数换底对数求导法要用到">对数换底（对数求导法要用到）</h2><p><span class="math display">\[y=x^{\sin x}\Rightarrow \ln y=ln x^{\sin x}\Rightarrow \ln y = \sin x \ln x\]</span></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;高中三角函数公式重要&quot;&gt;高中三角函数公式（重要）&lt;/h1&gt;
&lt;h2 id=&quot;反三角函数理清关系&quot;&gt;反三角函数（理清关系）&lt;/h2&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[y=\arcsin x\ \ \text{也即}\sin y=x
      
    
    </summary>
    
      <category term="高等数学" scheme="http://yoursite.com/categories/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/"/>
    
    
      <category term="导数与微分" scheme="http://yoursite.com/tags/%E5%AF%BC%E6%95%B0%E4%B8%8E%E5%BE%AE%E5%88%86/"/>
    
      <category term="三角函数" scheme="http://yoursite.com/tags/%E4%B8%89%E8%A7%92%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>函数与极限</title>
    <link href="http://yoursite.com/2020/01/06/%E5%87%BD%E6%95%B0%E4%B8%8E%E6%9E%81%E9%99%90/"/>
    <id>http://yoursite.com/2020/01/06/函数与极限/</id>
    <published>2020-01-06T05:45:38.543Z</published>
    <updated>2020-01-06T05:45:38.543Z</updated>
    
    <content type="html"><![CDATA[<h1 id="函数">函数</h1><h2 id="绝对值函数">绝对值函数</h2><p><span class="math inline">\(y = |x|\)</span></p><p>值部分（python伪代码）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if x &lt; 0</span><br><span class="line">    y &#x3D; -1</span><br><span class="line"></span><br><span class="line">elif x &#x3D;&#x3D; 0</span><br><span class="line">    y &#x3D; 0</span><br><span class="line"></span><br><span class="line">else x &gt; 0</span><br><span class="line">    y &#x3D; 1</span><br></pre></td></tr></table></figure><h2 id="取整函数向下取整">取整函数（向下取整）</h2><p>表现形式：<span class="math inline">\(\sqrt{2}=1\)</span></p><p>就如这么表示：<span class="math inline">\([x]\)</span></p><h2 id="分段函数">分段函数</h2><p>值部分分别表示就算分段函数</p><h2 id="复合函数">复合函数</h2><p><span class="math inline">\((f∘g)(x) = f[g(x)]\)</span></p><h1 id="双曲函数">双曲函数</h1><p>双曲正弦：<span class="math inline">\(sh x = \frac{e^{x} - e^{-x}}{2}\)</span></p><p>双曲余弦：<span class="math inline">\(ch x = \frac{e^{x} + e^{-x}}{2}\)</span></p><p>双曲正切：<span class="math inline">\(th x = \frac{sh x}{ch x} = \frac{e^{x} - e^{-x}}{e^{x} + e^{-x}}\)</span></p><p>反双曲正弦： <span class="math inline">\(arsh x = ln(x + \sqrt{x^2 + 1})\)</span></p><p>反双曲余弦： <span class="math inline">\(arch x = ln(x + \sqrt{x^2 - 1})\)</span></p><p>反双曲正切： <span class="math inline">\(arth x = \frac{1}{2} * ln \frac{1 + x}{1 - x}\)</span></p><h1 id="两个重要极限重要">两个重要极限（重要！）</h1><ol type="1"><li><p><span class="math inline">\(\lim_{n \to 0} \ \frac{\sin x}{x}=1\)</span></p></li><li><p><span class="math inline">\(\lim_{n \to \infty} (1+\frac{1}{x})^{x} = e\)</span></p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;函数&quot;&gt;函数&lt;/h1&gt;
&lt;h2 id=&quot;绝对值函数&quot;&gt;绝对值函数&lt;/h2&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(y = |x|\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;值部分（python伪代码）&lt;/p&gt;
&lt;figure class=&quot;h
      
    
    </summary>
    
      <category term="高等数学" scheme="http://yoursite.com/categories/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/"/>
    
    
      <category term="函数与极限" scheme="http://yoursite.com/tags/%E5%87%BD%E6%95%B0%E4%B8%8E%E6%9E%81%E9%99%90/"/>
    
  </entry>
  
  <entry>
    <title>最小表示法</title>
    <link href="http://yoursite.com/2020/01/06/%E6%9C%80%E5%B0%8F%E8%A1%A8%E7%A4%BA%E6%B3%95/"/>
    <id>http://yoursite.com/2020/01/06/最小表示法/</id>
    <published>2020-01-06T03:58:45.695Z</published>
    <updated>2019-11-16T11:58:03.345Z</updated>
    
    <content type="html"><![CDATA[<p>#前记 偶然刷题碰见的一个自己没碰过的算法，顺手就记录下来了，后边链接是OI wiki的学习链接 <a href="https://oi-wiki.org/string/minimal-string/" target="_blank" rel="noopener" class="uri" title="OI wiki的链接">https://oi-wiki.org/string/minimal-string/</a></p><p>#算法介绍 最小表示法是用于解决字符串最小表示问题的方法，就是说字符串s[0]换到s[s.size()]，哪种表示方法的值是最小的，输出的是最小开始起点下标</p><p>不多说废话了直接贴代码 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int k &#x3D; 0, i &#x3D; 0, j &#x3D; 1;</span><br><span class="line">while (k &lt; n &amp;&amp; i &lt; n &amp;&amp; j &lt; n) &#123;</span><br><span class="line">if (sec[(i + k) % n] &#x3D;&#x3D; sec[(j + k) % n]) &#123;</span><br><span class="line">k++;</span><br><span class="line">&#125; </span><br><span class="line">else &#123;</span><br><span class="line">sec[(i + k) % n] &gt; sec[(j + k) % n] ? i &#x3D; i + k + 1 : j &#x3D; j + k + 1;</span><br><span class="line">    if (i &#x3D;&#x3D; j) i++;</span><br><span class="line">    k &#x3D; 0;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">i &#x3D; min(i, j);&#x2F;&#x2F;最小就用这个</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;#前记 偶然刷题碰见的一个自己没碰过的算法，顺手就记录下来了，后边链接是OI wiki的学习链接 &lt;a href=&quot;https://oi-wiki.org/string/minimal-string/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot; clas
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="ACM" scheme="http://yoursite.com/tags/ACM/"/>
    
      <category term="字符串算法" scheme="http://yoursite.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>康托展开</title>
    <link href="http://yoursite.com/2020/01/06/%E5%BA%B7%E6%89%98%E5%B1%95%E5%BC%80/"/>
    <id>http://yoursite.com/2020/01/06/康托展开/</id>
    <published>2020-01-06T03:58:45.680Z</published>
    <updated>2019-11-16T11:56:32.622Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前记">前记</h1><p>刷Aizu 0121时，这道题是需要用到康托展开作为hash，然后在这里进行a*或者bfs。借此契机重新复习（预习）一遍康托展开。原创链接，在基础上增加了自己的理解： <a href="https://oi-wiki.org/math/cantor/" target="_blank" rel="noopener" class="uri" title="康托展开">https://oi-wiki.org/math/cantor/</a></p><h1 id="康托展开算法介绍">康托展开算法介绍</h1><p>这个算法是已知一个排列，算它在全排列中排第几位，假如例子长度为5，数组数据为 [3, 2, 5, 4, 1]，那么康托展开的答案就是 2 * 4!（代表如果最高位取1或者2时数字比现在数字小）+ 1 * 3! + 2 * 2! + 1 * 1! = 59（该数组全排列大小在所有全排列数组中有59个数比这个数字字典序要小，从0数起；变相就是从1数起排名60位）。 再一个例子： [2, 5, 3, 4, 1]，答案就是1 + 4! + 3 * 3! + 2! = 45，如果计算排名就是在return那里+1就行了。</p><h2 id="算法模板">算法模板</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int kantor(int *num, int n)&#123;</span><br><span class="line">    int ans &#x3D; 0;</span><br><span class="line">    for(int i &#x3D; 0; i &lt; n; i++)&#123;</span><br><span class="line">        int x &#x3D; 0, c &#x3D; 1, m &#x3D; 1;</span><br><span class="line"></span><br><span class="line">        for(int j &#x3D; i + 1; j &lt; n; j++)&#123;</span><br><span class="line">            if(num[j] &lt; num[i])&#123;</span><br><span class="line">                x++;</span><br><span class="line">            &#125;</span><br><span class="line">            m *&#x3D; c;</span><br><span class="line">            c++;</span><br><span class="line">        &#125;</span><br><span class="line">        ans +&#x3D; x * m;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="逆康托展开">逆康托展开</h1><p>康托展开出来的排名和排列顺序是一一对应的 如果要逆向这个过程，引用上面自己的样例[3, 2, 5, 4, 1]，ans = 59代表有59个数比这个数字的字典序要小。先将计算出来的答案/4!，就是第一位数是啥，也即59 / (4 * 3 * 2 * 1) = 2.xxxxxx ≈ 2（向下取整），证明出来了第一位数是 3 。计算第二个位数时，先将前面计算得到的去掉，即59 - 2 * 24 = 11，然后11 / 3! = 1.xxxx ≈ 1，证明前面有1个数字小于它，第二位是2。以此类推，第三位是5 / 2! = 2.5约等于2，得出来是5。最后一位就是1了！</p><h2 id="算法模板-1">算法模板</h2><p>还未找到，先放在这里</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="算法优化">算法优化</h1><p>这个算法时间复杂度是O(n^2)，看博客介绍说是可以用线段树维护使时间复杂度降为O(nlogn)，具体怎么维护还不太清楚，先放这里等进一步补充</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前记&quot;&gt;前记&lt;/h1&gt;
&lt;p&gt;刷Aizu 0121时，这道题是需要用到康托展开作为hash，然后在这里进行a*或者bfs。借此契机重新复习（预习）一遍康托展开。原创链接，在基础上增加了自己的理解： &lt;a href=&quot;https://oi-wiki.org/mat
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="ACM" scheme="http://yoursite.com/tags/ACM/"/>
    
      <category term="未完整博客" scheme="http://yoursite.com/tags/%E6%9C%AA%E5%AE%8C%E6%95%B4%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="数论" scheme="http://yoursite.com/tags/%E6%95%B0%E8%AE%BA/"/>
    
      <category term="组合数学" scheme="http://yoursite.com/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>KMP算法</title>
    <link href="http://yoursite.com/2020/01/06/KMP%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2020/01/06/KMP算法/</id>
    <published>2020-01-06T03:58:45.664Z</published>
    <updated>2019-10-24T10:12:39.204Z</updated>
    
    <content type="html"><![CDATA[<h1 id="kmp算法">KMP算法</h1><p>现有字符串A,B A为文本，B为匹配字符</p><h2 id="自己匹配自己">自己匹配自己</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">next[1] &#x3D; 0</span><br><span class="line"></span><br><span class="line">k &#x3D; 0</span><br><span class="line"></span><br><span class="line">for i &#x3D; 2 to B.length()</span><br><span class="line">while k &gt; 0 &amp;&amp; B[k + 1] !&#x3D; B[i]</span><br><span class="line">k &#x3D; next[k]</span><br><span class="line"></span><br><span class="line">if B[k + 1] &#x3D;&#x3D; B[i]</span><br><span class="line">k++</span><br><span class="line"></span><br><span class="line">next[i] &#x3D; k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">void getnext_v() &#123;</span><br><span class="line">int j, k, len &#x3D; strlen(s);</span><br><span class="line"></span><br><span class="line">j &#x3D; 0;</span><br><span class="line">k &#x3D; -1;</span><br><span class="line">Next[0] &#x3D; -1;</span><br><span class="line">while(j &lt; len) &#123;</span><br><span class="line">if (k &#x3D;&#x3D; -1 || s[j] &#x3D;&#x3D; s[k]) &#123;</span><br><span class="line">j++;</span><br><span class="line">k++;</span><br><span class="line">Next[j] &#x3D; k;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">k &#x3D; Next[k];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="目标串匹配文本">目标串匹配文本</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">k &#x3D; 0</span><br><span class="line"></span><br><span class="line">for i &#x3D; 1 to A.length()</span><br><span class="line">while k &gt; 0 &amp;&amp; B[k + 1] !&#x3D; A[i]</span><br><span class="line">k &#x3D; next[k]</span><br><span class="line"></span><br><span class="line">if B[k + 1] &#x3D;&#x3D; A[i]</span><br><span class="line">k++</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;匹配到相应字符串</span><br><span class="line">if k &#x3D;&#x3D; m:</span><br><span class="line">&#x2F;&#x2F;匹配到的字符串起始位置</span><br><span class="line">pos &#x3D; i - m + 1</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;寻找下一个位置</span><br><span class="line">k &#x3D; next[k]</span><br></pre></td></tr></table></figure><h2 id="next数组理解">Next数组理解</h2><p>例题：POJ-2752</p><p>题目大意：求一个字符串的子串是和字符串相同前后缀的位置</p><p>根据Next数组，回溯Next数组代表着从当前的第k个到Next[k]指向的位置，字符串的前缀字符子串和当前部分字符子串是相等的。</p><p>程序代码： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">typedef long long ll;</span><br><span class="line"></span><br><span class="line">const int inf &#x3D; 0x3f3f3f3f;</span><br><span class="line">const int MAXN &#x3D; 1000005;</span><br><span class="line"> </span><br><span class="line">string s;</span><br><span class="line">int fail[MAXN];</span><br><span class="line">int ans[MAXN];</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">ios::sync_with_stdio(false);</span><br><span class="line">cin.tie(0);</span><br><span class="line">cout.tie(0);</span><br><span class="line"></span><br><span class="line">while (cin &gt;&gt; s) &#123;</span><br><span class="line">fail[0] &#x3D; -1;</span><br><span class="line"></span><br><span class="line">int k &#x3D; -1;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;KMP匹配部分，其中Next数组（也即这里的fail数组，下面都称为fail数组）下标i对应的是字符串的i-1位</span><br><span class="line">for (int i &#x3D; 0; i &lt; s.size();) &#123;</span><br><span class="line">if (k &#x3D;&#x3D; -1 || s[i] &#x3D;&#x3D; s[k]) &#123;</span><br><span class="line">i++, k++;</span><br><span class="line">fail[i] &#x3D; k;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">k &#x3D; fail[k];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;调试输出fail数组部分</span><br><span class="line">&#x2F;*for (int i &#x3D; 0; i &lt;&#x3D; s.size(); i++) &#123;</span><br><span class="line">printf(&quot;%d &quot;, fail[i]);</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;\n&quot;);*&#x2F;</span><br><span class="line">&#x2F;&#x2F;printf(&quot;%s&quot;, s);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;回溯部分</span><br><span class="line">int pos &#x3D; s.size();</span><br><span class="line">stack &lt;int&gt; st;</span><br><span class="line">while (pos &gt; 0) &#123;</span><br><span class="line">st.push(pos);</span><br><span class="line">pos &#x3D; fail[pos];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;cout &lt;&lt; st.size() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">while (!st.empty()) &#123;</span><br><span class="line">cout &lt;&lt; st.top() &lt;&lt; &quot; &quot;;</span><br><span class="line">st.pop();</span><br><span class="line"></span><br><span class="line">first &#x3D; false;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="扩展kmp算法">扩展KMP算法</h1><p>next所代表的意思是接下来有几个字符是可以匹配到的</p><p>比如aaaaab，自己匹配自己后，next数组的值为6 4 3 2 1 0</p><p>如果用普通KMP匹配的话，next数组的值则会为0 1 2 3 4 0</p><p>例题模板（HDU-2594）部分</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">while (cin &gt;&gt; a &gt;&gt; b) &#123;</span><br><span class="line">Next[0] &#x3D; a.size();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;前面</span><br><span class="line">int q &#x3D; 0;</span><br><span class="line">int p &#x3D; 0;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;扩展KMP自己匹配自己过程（也既a匹配a）</span><br><span class="line">for (int i &#x3D; 1; i &lt; a.size(); i++) &#123;</span><br><span class="line">if (i &gt;&#x3D; p || i + Next[i - q] &gt;&#x3D; p) &#123;</span><br><span class="line">if (i &gt;&#x3D; p) &#123;</span><br><span class="line">p &#x3D; i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">while (p &lt; a.size() &amp;&amp; a[p] &#x3D;&#x3D; a[p - i]) &#123;</span><br><span class="line">p++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Next[i] &#x3D; p - i;</span><br><span class="line">q &#x3D; i;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">Next[i] &#x3D; Next[i - q];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">q &#x3D; 0, p &#x3D; 0;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;扩展KMP a匹配b过程</span><br><span class="line">for (int i &#x3D; 0; i &lt; b.size(); i++) &#123;</span><br><span class="line">if (i &gt;&#x3D; p || i + Next[i - q] &gt;&#x3D; p) &#123;</span><br><span class="line">if (i &gt;&#x3D; p) &#123;</span><br><span class="line">p &#x3D; i;</span><br><span class="line">&#125;</span><br><span class="line">while (p &lt; b.size() &amp;&amp; p - i &lt; a.size() &amp;&amp; b[p] &#x3D;&#x3D; a[p - i]) &#123;</span><br><span class="line">p++;</span><br><span class="line">&#125;</span><br><span class="line">Extend[i] &#x3D; p - i;</span><br><span class="line">q &#x3D; i;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">Extend[i] &#x3D; Next[i - q];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int ret &#x3D; 0;</span><br><span class="line"></span><br><span class="line">for (int i &#x3D; 0; i &lt; b.size(); i++) &#123;</span><br><span class="line">if (Extend[i] &gt; ret &amp;&amp; Extend[i] + i &#x3D;&#x3D; b.size()) &#123;</span><br><span class="line">ret &#x3D; Extend[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*if (!ret) &#123;</span><br><span class="line">cout &lt;&lt; 0 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">for (int i &#x3D; b.size() - ret; i &lt; b.size(); i++) &#123;</span><br><span class="line">cout &lt;&lt; b[i];</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; &quot; &quot; &lt;&lt; ret &lt;&lt; endl;</span><br><span class="line">&#125;*&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 打印 next</span><br><span class="line">cout &lt;&lt; &quot;next:   &quot;;</span><br><span class="line">for (int i &#x3D; 0; i &lt; a.size(); i++)</span><br><span class="line">cout &lt;&lt; Next[i] &lt;&lt; &quot; &quot;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 打印 extend</span><br><span class="line">cout &lt;&lt; &quot;\nextend: &quot;;</span><br><span class="line">for (int i &#x3D; 0; i &lt; b.size(); i++)</span><br><span class="line">cout &lt;&lt; Extend[i] &lt;&lt; &quot; &quot;;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;kmp算法&quot;&gt;KMP算法&lt;/h1&gt;
&lt;p&gt;现有字符串A,B A为文本，B为匹配字符&lt;/p&gt;
&lt;h2 id=&quot;自己匹配自己&quot;&gt;自己匹配自己&lt;/h2&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;g
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="ACM" scheme="http://yoursite.com/tags/ACM/"/>
    
      <category term="字符串算法" scheme="http://yoursite.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>AC自动机</title>
    <link href="http://yoursite.com/2020/01/06/AC%E8%87%AA%E5%8A%A8%E6%9C%BA/"/>
    <id>http://yoursite.com/2020/01/06/AC自动机/</id>
    <published>2020-01-06T03:58:45.649Z</published>
    <updated>2019-11-13T03:03:29.701Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前记">前记</h1><p><a href="https://oi-wiki.org/string/ac-automaton/" target="_blank" rel="noopener" title="OI wiki的链接">https://oi-wiki.org/string/minimal-string/</a> 讲道理这个链接我看不太明白，然后又转到csdn的博客学习了一波</p><h1 id="算法介绍">算法介绍</h1><p>多模匹配算法，多单词匹配一个字符串算法。</p><h1 id="算法代码">算法代码</h1><p>例题HDU - 2222 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line"></span><br><span class="line">const int maxn &#x3D; 1e3 + 50;</span><br><span class="line"></span><br><span class="line">struct Node&#123;</span><br><span class="line">    int cnt;</span><br><span class="line">    Node *fail;</span><br><span class="line">    Node *next[26];</span><br><span class="line">&#125;*q[500005];&#x2F;&#x2F;q为一个模拟队列，可以用队列</span><br><span class="line">char s[1000005];</span><br><span class="line">char keyword[55];</span><br><span class="line">Node *root;</span><br><span class="line"></span><br><span class="line">void Init(Node *root)&#123;</span><br><span class="line">    root-&gt;cnt&#x3D;0;</span><br><span class="line">    root-&gt;fail&#x3D;NULL;</span><br><span class="line">    for(int i &#x3D; 0; i &lt; 26; i++)&#123;</span><br><span class="line">        root-&gt;next[i]&#x3D;NULL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;建立字典树</span><br><span class="line">void Build_trie(char *keyword)&#123;</span><br><span class="line">    Node *p, *q;</span><br><span class="line">    int i, v;</span><br><span class="line">    int len &#x3D; strlen(keyword);</span><br><span class="line"></span><br><span class="line">    for(i &#x3D; 0, p &#x3D; root; i &lt; len; i++)&#123;</span><br><span class="line">        v &#x3D; keyword[i]-&#39;a&#39;;</span><br><span class="line">        if(p-&gt;next[v] &#x3D;&#x3D; NULL)&#123;</span><br><span class="line">&#x2F;&#x2F;          分配一块内存空间给q</span><br><span class="line">            q &#x3D; (struct Node *)malloc(sizeof(Node));</span><br><span class="line">            Init(q);</span><br><span class="line">            p-&gt;next[v] &#x3D; q;</span><br><span class="line">        &#125;</span><br><span class="line">        p&#x3D;p-&gt;next[v];</span><br><span class="line">    &#125;</span><br><span class="line">&#x2F;&#x2F;    单词的最后一个字母节点cnt++，代表一个完整单词</span><br><span class="line">    p-&gt;cnt++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;建立ac自动机</span><br><span class="line">void Build_AC_automation(Node *root)&#123;</span><br><span class="line">&#x2F;&#x2F;    队列头尾指针</span><br><span class="line">    int head &#x3D; 0, tail &#x3D; 0;</span><br><span class="line">&#x2F;&#x2F;    现将root入队q</span><br><span class="line">    q[head++] &#x3D; root;</span><br><span class="line">    while(head !&#x3D; tail)&#123;</span><br><span class="line">        Node *p &#x3D; NULL;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;        弹出队头节点</span><br><span class="line">        Node *temp &#x3D; q[tail++];</span><br><span class="line"></span><br><span class="line">        for(int i &#x3D; 0; i &lt; 26; i++)&#123;</span><br><span class="line">            if(temp-&gt;next[i] !&#x3D; NULL)&#123;</span><br><span class="line">                if(temp &#x3D;&#x3D; root)&#123;</span><br><span class="line">&#x2F;&#x2F;                    如弹出队列的为根节点</span><br><span class="line">                    temp-&gt;next[i]-&gt;fail&#x3D;root;</span><br><span class="line">                &#125;</span><br><span class="line">                else&#123;</span><br><span class="line">                    p&#x3D;temp-&gt;fail;</span><br><span class="line">                    while(p !&#x3D; NULL)&#123;</span><br><span class="line">                        if(p-&gt;next[i] !&#x3D; NULL)&#123;</span><br><span class="line">                            temp-&gt;next[i]-&gt;fail&#x3D;p-&gt;next[i];</span><br><span class="line">                            break;</span><br><span class="line">                        &#125;</span><br><span class="line">                        p&#x3D;p-&gt;fail;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    if(p &#x3D;&#x3D; NULL)&#123;</span><br><span class="line">                        temp-&gt;next[i]-&gt;fail &#x3D; root;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                q[head++]&#x3D;temp-&gt;next[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int query(Node *root)&#123;</span><br><span class="line">&#x2F;&#x2F;    i为主串指针，p为模式串指针</span><br><span class="line">    int i, v, cnt &#x3D; 0;</span><br><span class="line">    Node *p &#x3D; root;</span><br><span class="line">    int len &#x3D; strlen(s);</span><br><span class="line">    for(i &#x3D; 0; i &lt; len; i++)&#123;</span><br><span class="line">        v&#x3D;s[i] - &#39;a&#39;;</span><br><span class="line">&#x2F;&#x2F;        失败指针回溯查找，判断s[i]是否存在于字典树中</span><br><span class="line">        while(p-&gt;next[v] &#x3D;&#x3D; NULL &amp;&amp; p !&#x3D; root)&#123;</span><br><span class="line">            p&#x3D;p-&gt;fail;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        p&#x3D;p-&gt;next[v];</span><br><span class="line"></span><br><span class="line">        if(p &#x3D;&#x3D; NULL)&#123;</span><br><span class="line">            p &#x3D; root;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Node *temp &#x3D; p;</span><br><span class="line">        while(temp !&#x3D; root)&#123;</span><br><span class="line">            if(temp-&gt;cnt &gt;&#x3D; 0)&#123;</span><br><span class="line">                cnt +&#x3D; temp-&gt;cnt;</span><br><span class="line">                temp-&gt;cnt&#x3D; -1;</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            temp&#x3D;temp-&gt;fail;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    ios::sync_with_stdio(false);</span><br><span class="line">    cin.tie(0);</span><br><span class="line">    cout.tie(0);</span><br><span class="line"></span><br><span class="line">    int T, n;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">    while(T--)&#123;</span><br><span class="line">        root &#x3D; (struct Node *)malloc(sizeof(Node));</span><br><span class="line">        Init(root);</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">        for(int i &#x3D; 0; i &lt; n; i++)&#123;</span><br><span class="line">            scanf(&quot;\n%s&quot;, keyword);</span><br><span class="line">            Build_trie(keyword);</span><br><span class="line">        &#125;</span><br><span class="line">        Build_AC_automation(root);</span><br><span class="line">        scanf(&quot;\n%s&quot;, s);</span><br><span class="line">        printf(&quot;%d\n&quot;, query(root));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前记&quot;&gt;前记&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;https://oi-wiki.org/string/ac-automaton/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot; title=&quot;OI wiki的链接&quot;&gt;https://oi-wiki
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="ACM" scheme="http://yoursite.com/tags/ACM/"/>
    
      <category term="字符串算法" scheme="http://yoursite.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%AE%97%E6%B3%95/"/>
    
      <category term="未完整博客" scheme="http://yoursite.com/tags/%E6%9C%AA%E5%AE%8C%E6%95%B4%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
</feed>
